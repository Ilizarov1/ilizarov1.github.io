# JS 的异步

## 1. 基本介绍

- JS 是单线程语言，异步任务需要等待线程执行完所以同步任务后才能执行

- JS 引擎执行时，每当遇到异步任务就将其加入任务队列，等待合适时机执行

- 当线程中的任务执行完成后，事件循环会依次执行任务队列中的任务

## 2. 事件循环

[深入：微任务与Javascript运行时环境 - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88event_loops%EF%BC%89)

- 在执行 JS 代码时，运行时实际上维护着一组用于执行 JS 代码的代理，每个代理由执行上下文、执行上下文栈、主线程、一组可能创建 worker 的额外线程集合、一个任务队列和一个微任务队列。

- 每个代理均由事件循环驱动，事件循环负责收集用户事件、对事件排队并在合适时机调用回调函数，然后执行所有在等待中的任务，再是微任务，最后在下一次循环之前执行必要的渲染和绘制。

- 三种事件循环：
  
  - window 事件循环
  
  - worker 事件循环
  
  - worklet 事件循环

- 特定情况下共享事件循环：
  
  - 一个窗口打开了另一个窗口，可能共享
  
  - iframe 会和包含它的窗口共享
  
  - 多进程浏览器中多个窗口碰巧共享同一进程

## 3. 任务和微任务

- 每次事件循环开始时，先执行任务队列，再执行微任务队列

- 任务队列在执行完毕后，必须等待下一次事件循环才能执行

- 在本次循环中增加到微任务队列的微任务，会在本次循环中执行完

# 异步方案

## 1. 回调函数

两个问题：回调地狱和信任问题

信任问题：回调机制将函数的控制权交给了第三方，第三方决定函数的运行环境和时机，主线程和第三方之间也没有达成契约或者协议，因此形成了控制的反转，产生信任问题。

这种信任问题包括但不限于：

1. 调用过早过晚或者不调用
2. 调用次数过多或过少
3. 没有传递需要的环境和参数
4. 吞掉异常

## 2. Promise

弥补回调地狱和信任问题

- 解决回调地狱：链式调用
- 解决信任问题：控制反转的反转，让第三方提供解决问题的能力并告知解决问题的时机，仍由主线程决定函数的执行环境和如何调用
- 解决信任问题是Promise范式的核心

### Promise 的一静态些方法

- Promise.all：传入 Promise[] ，返回决议后的结果数组，有任何一个被拒绝，则整体被拒绝，返回第一个拒绝的原因 （并发方法，如果想要其中一个出错就返回
- Promise.allSettled：传入 Promise[] ，返回决议后的状态数组，{ status, value, reason } []，无论是被拒绝还是决议成功（并发方法，如果不关心是否发生错误
- Promise.race：传入 Promise[]，返回第一个决议后的 promise实例（如果不关心决议状态，可以实现异步超时控制器
- Promise.any：传入 Promise[]，返回第一个被兑现后的promise结果（如果关系决议状态
- Promise.resolve
- Promise.reject

## 3. async/await

async/await 是迭代器、生成器以及Promise的语法糖，实质是自动执行的异步迭代生成器

- 被async 包裹的函数会返回Promise

```js
async function asyncExec() {
    await request(/*..*/);
    doSomething();
}
// 可以等价为
run(function *asyncExec() {
    yield request(/*...*/);
    doSomething();
})

```

- run() 是一个可以自动执行生成器的辅助函数
- 实现异步代码的同步编写
- 支持更好的异常捕获 try-catch-finally

