# 模块化开发

## 1. 为什么

代码量增大，必须实现解耦合，高内聚，否则维护困难

## 2. 怎么做

落实在js上的话，现在最常见的做法就是写立即函数，利用闭包实现变量的私有，保证不会污染模块外的作用域

## 3. 几种模块化规范

- CommonJS：
  - require引入，module.exports作为输出接口
  - 同步加载
  - 常用在服务端（因为模块文件都在本地，读取很快，用同步加载没问题），在浏览器端就不合适
- AMD：
  - 异步加载
  - 模块加载不影响后面语句的执行
  - 所有依赖模块的语句都定义在一个回调函数里，模块加载完以后执行
- CMD
  - 异步加载
  - 和AMD区别在于对模块定义时对依赖的处理不同和执行时机不同
  - 1. AMD就是要模块前置，在定义模块的时候就要把依赖写好；CMD就是要就近，用到的时候再去require
    2. AMD的话就是加载完直接就执行了，依赖的执行顺序和书写顺序可能是不一样的；CMD的话就是全部依赖加载完以后再调用回调函数，遇到require再执行，和书写顺序是一致的
- ES6
  - 语言标准层面
  - import和export
  - 和CommonJS的差异：
    - 模块输出方式：commonJs是值的拷贝，输出以后，模块内部不能再对这个值产生影响；ES6则是值的引用，js引擎加载的时候遇到import就是产生一个只读引用，全部加载完以后，再到模块内部取值
    - 加载方式：commonjs是运行时加载，加载整个模块，输出一个对象，通过对象调用方法；es6则是静态接口的形式，加载完以后通过这个接口到内部去取值

## 4. require.js的核心原理

require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。